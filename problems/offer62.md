# 剑指 Offer 62. 圆圈中最后剩下的数字

## 题目描述

这是LeetCode上的[剑指 Offer 62. 圆圈中最后剩下的数字](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/)， 难度为简单

0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。

例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。

### 示例1

```
输入: n = 5, m = 3
输出: 3
```

### 示例2

```
输入: n = 10, m = 17
输出: 2
```

### 限制

- `1 <= n <= 10^5`
- `1 <= m <= 10^6`

## 解答

### 数学方法

以 `n=5, m=3`为例，我们得到的初始数组是：`0 1 2 3 4`， 在删除第三个数字之后，也就是删除2之后，变成`3 4 0 1`，具体过程如下：

```
#	0 1 2 3 4 0 1 2 3 4 -> 3 4 0 1 3 4 0 1
#	3 4 0 1 3 4 0 1 -> 1 3 4 1 3 4
# 1 3 4 1 3 4 -> 1 3 1 3
# 1 3 1 3 -> 3 3
```

由此，我们可以观察出两个最后剩下的数字的特性，即：

* 最后剩下的数字在最后的一轮循环结束之后下标一定是0
* 每次循环的下标为0的数字一定是上一次循环中下表为3的数字
* 每次循环只删除一个数字

推广可知，我们应该要一共经历n次循环，第k+1次循环的下标为0的数字一定是第k次循环下标为m的数字，且最后剩余的数字在最后一次循环中一定下标为0，因此我们可以逆退，得到关系式`ans = (ans + m)%i`。

#### Java实现

```java
class Solution {
    public int lastRemaining(int n, int m) {
        int ans = 0;
        for(int i = 2; i <= n; i ++){
            ans = (ans + m)%i;
        }
        return ans;
    }
}
```

* 时间复杂度：因为进行了n次循环，因此时间复杂度为$O(n)$
* 空间复杂度：因为我们没有使用额外的内存空间，因此空间复杂度为$O(1)$

#### C++实现

```C++
class Solution {
public:
    int lastRemaining(int n, int m) {
        int ans = 0;
        for(int i = 2; i <= n; i++){
            ans = (ans + m)%i;
        }
        return ans;
    }
};
```

* 时间复杂度：因为进行了n次循环，因此时间复杂度为$O(n)$
* 空间复杂度：因为我们没有使用额外的内存空间，因此空间复杂度为$O(1)$

#### Python3实现

```python
class Solution:
    def lastRemaining(self, n: int, m: int) -> int:
        ans = 0
        for i in range(2, n + 1) :
            ans = (ans + m)%i
        return ans
```

* 时间复杂度：因为进行了n次循环，因此时间复杂度为$O(n)$
* 空间复杂度：因为我们没有使用额外的内存空间，因此空间复杂度为$O(1)$
